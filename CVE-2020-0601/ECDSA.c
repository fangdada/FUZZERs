#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

int mod = 0x7F;
// int mod = 23;
unsigned char ECCPoints[0x80];

// model 'y^2 = x^3 + a*x + b' ;
// using 'y^2 = x^3 + 2*x + 3' ;
int A = 2;
int B = 3;

typedef struct point{
	int x;
	int y;
}Point;

typedef struct dsaciphercouple{
	Point C1;
	unsigned int C2;
	struct dsaciphercouple* Next;
}DSACipherCouple;

Point ZeroPoint = {0, 0};

int mmod(int num, int p)
{
	int result = num % p;

	if(result >= 0)
		return result;
	else
		return result + p;
}


// x/y mod p = result
// enumberate m to solve
// x + y*m mod p == 0
int fraction_mod(int x, int y, int p)
{
	if(y == 0)
		goto _Traced;

	for(int m=0; m<p; m++)
	{
		if(mmod((x + y*m), p) == 0)
			return p-m;
	}
	
_Traced:
	//printf("faction_mod traced[%d/%d]\n", x, y);
	return -1;
}

// P(x1, y1) + Q(x2, y2) = R(x3, y3)
// P == Q && k = (3 * x^2 + a)/(2 * y)
// P != Q && k = (y2-y1)/(x2-x1)
// x3 = (k^2 - x1- x2) mod p;
// y3 = (k*(x1 - x3) - y1) mod p;
Point PointAdd(Point P, Point Q, int p)
{
	Point result;
	int k;


	if(!memcmp(&P, &ZeroPoint, sizeof(Point)))
		return Q;
	else if(!memcmp(&Q, &ZeroPoint, sizeof(Point)))
		return P;
	else if(!memcmp(&P, &Q, sizeof(Point)))
		k = fraction_mod(3 * P.x * P.x + A, 2 * P.y, p);
	else
		k = fraction_mod(Q.y - P.y, Q.x - P.x, p);

	if(k == -1)
	{
		result.x = 0;
		result.y = 0;
	}
	else
	{
		result.x = mmod((k*k - P.x - Q.x), p);
		result.y = mmod((k*(P.x - result.x) - P.y), p);
	}
	
	return result;
}

Point PointSub(Point P, Point Q, int p)
{
	Q.y = (-Q.y);
	return PointAdd(P, Q, p);
}

// 3G = 2G + G
// 2G = G + G  
// 3G = (G + G) + G  (3, 2)
Point PointMulti(unsigned int r, Point G, int p)
{
	Point result;
	result.x = G.x;
	result.y = G.y;

	if(r > 1)
		return PointAdd(result, PointMulti(r-1, G, p), p);
	else
		return result;
}

void InitECCKeys(unsigned int k, Point G,  Point* K, int p)
{
	Point* pK = K;
	*pK = PointMulti(k, G, p);
}

/*
void InitECCPoints(int p)
{
	int x, y;

	memset(ECCPoints, 0xFF, 0x80);

	for(x = 0; x < 0x7F; x++)
	{
		for(y = 0; y < 0x7F; y++)
		{
			if(mmod(pow(x,3) + x*A + B, p) == mmod(pow(y, 2), p))
			{
				ECCPoints[x]=y;
				break;
			}
		}
	}
}
*/

int ECCOrder(Point G, int max, int p)
{
	int n;
	Point tmpPoint;

	for(n = 0; n < max; n++)
	{
		tmpPoint = PointMulti(n, G, p);
		if(!memcmp(&tmpPoint, &ZeroPoint, sizeof(Point)))
			return n;
	}

	return -1;
}

int main(int argc, char** argv)
{
	Point K, G, rG, result;
	int k, r, n, m, h;
	int s, x;
	DSACipherCouple DSACipher;

	G.x = 3;
	G.y = 6;

	printf("use EC: y^2 = x^3 + %d*x + %d\n", A, B);
	printf("use G{%d, %d}\n", G.x, G.y);
	//InitECCPoints(mod);
	n = ECCOrder(G, mod, mod);
	if(n != -1)
	{
		printf("The order of G is: %d\n", n);
		k = n-1;
		r = n-2;
	}
	else
	{
		printf("Order of G not found!\n");
		return 1;
	}

	InitECCKeys(k, G, &K, mod);

	printf("private key: %d\trandom num: %d\n", k, r);
	printf("public key K{%d, %d}\n", K.x, K.y);


	rG = PointMulti(r, G, mod);
	x = rG.x;
	
	h = 13;

	s = fraction_mod(h + k*x, r, n);
	if(s == -1)
	{
		printf("Invalid s calc.\n");

	}
	DSACipher.C1 = rG;
	DSACipher.C2 = s;


	result = PointAdd(PointMulti(fraction_mod(h, s, n), G, mod), PointMulti(fraction_mod(x, s, n), K, mod), mod);
	printf("result: {%d, %d}\n", result.x, result.y);
	printf("rG: {%d, %d}\n", rG.x, rG.y);

	if(!memcmp(&result, &rG, sizeof(Point)))
	{
		printf("ECDSA successful!\n");
	}
	else
	{
		printf("Failed to verify the hash.\n");
	}
	
	return 0;
}
