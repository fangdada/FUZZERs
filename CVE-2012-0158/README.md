> 环境：Windows7 x64 with sp1
>
> 漏洞软件：Office 2003 standard
>
> 漏洞文件：[mscomctl.ocx](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/mscomctl.ocx)
>
> 调试工具：x64dbg，IDA

&emsp;&emsp;<font size=2>这个就是最后一次复现栈溢出CVE了，栈溢出的原理理解起来比较简单，因此也就不打算自己写POC了，毕竟有一些pwn的基础就不搞简单的东西了，有意思的技术就等以后单独出demo吧。这里POC就用metasploit生成的MessageBox吧。</font></br>

&emsp;&emsp;<font size=2>对于CVE-2012-0158我们知道这是一个mscomctl.ocx控件里的一个栈溢出（找不到这个文件，我直接用调试器从内存中dump下来了），漏洞点在函数`0x275C876D`里的`0x275C87C8`，在IDA中是这样的：</font></br>

![IDA漏洞点](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/IDA漏洞点.png)

&emsp;&emsp;<font size=2>在x64dbg里面是这样子的：</font></br>

![漏洞点](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/漏洞点.png)

&emsp;&emsp;<font size=2>可以看到esi指向的就是POC，然后用offvis打开看看doc的结构：</font></br>

&emsp;&emsp;<font size=2>顺带一提，用msf生成的POC用Offvis直接解析不了，要把Magic签名`D0CF11E0`开始到最后的十六进制数据转化为</font></br>

![Offvis](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/Offvis.png)

&emsp;&emsp;<font size=2>到这里我们可以发现这是OLESSDirectoryEntry中名为Contents的data段长度未经检查得到的栈溢出漏洞。</font></br>

&emsp;&emsp;<font size=2>x64dbg里栈回溯，用IDA可以清晰的看到漏洞函数被调用了两次，前提是满足一个`v5 == 'jboC' && dwBytes >= 8`的条件：</font></br>

![IDA调用](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/IDA调用.png)

&emsp;&emsp;<font size=2>漏洞战争里给出了这里的结构体，定义如下：</font></br>

![结构体定义](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/结构体定义.png)

&emsp;&emsp;<font size=2>然后在实际样本里面结构体在这里：</font></br>

![结构体大小](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/结构体大小.png)

&emsp;&emsp;<font size=2>`0x8282`就是cbSize，在用`rep movsd`指令进行四字节的复制操作的时候就要`div 4`来得到实际复制的次数，所以ecx为`0x20A0`就可以理解了吧。构造这一个字段就可以任意控制复制的次数，实现覆盖栈任意大小了。metaspolit使用了`jmp esp`直接执行栈、花指令和SMC技术做了shellcode免杀，套路还是老样子，手动从PEB和kernel32.dll拿地址。最后调用MessageBox：</font></br>

![最终结果](https://raw.githubusercontent.com/fangdada/how2CVE/master/CVE-2012-0158/screenshot/最终结果.png)
